var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumUtilities","category":"page"},{"location":"#QuantumUtilities","page":"Home","title":"QuantumUtilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumUtilities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumUtilities]","category":"page"},{"location":"#QuantumUtilities.AntiCommutatorSuperOp-Tuple{Any}","page":"Home","title":"QuantumUtilities.AntiCommutatorSuperOp","text":"AntiCommutatorSuperOp(A)\n\nComputes the Liouville space superoperator representation of the anti-commutator with a matrix A.\n\nArguments\n\nA: The input matrix.\n\nReturns\n\nThe anti-commutator superoperator matrix obtained by adding the right superoperator of A to the left superoperator of A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> AntiCommutatorSuperOp(A)\n4×4 Matrix{Int64}:\n 2  2  3  0\n 3  5  0  3\n 2  0  5  2\n 0  2  3  8\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.CommutatorSuperOp-Tuple{Any}","page":"Home","title":"QuantumUtilities.CommutatorSuperOp","text":"CommutatorSuperOp(A)\n\nComputes the Liouville space superoperator representation of the commutator with a matrix A.\n\nArguments\n\nA: The input matrix.\n\nReturns\n\nThe commutator superoperator matrix obtained by subtracting the right superoperator of A from the left superoperator of A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> CommutatorSuperOp(A)\n4×4 Matrix{Int64}:\n  0   2  -3   0\n  3   3   0  -3\n -2   0  -3   2\n  0  -2   3   0\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.HamiltonianEvolutionSuperOp-Tuple{Any, Any}","page":"Home","title":"QuantumUtilities.HamiltonianEvolutionSuperOp","text":"HamiltonianEvolutionSuperOp(H, dt)\n\nComputes the superoperator corresponding to the Hamiltonian evolution of a system governed by the Hamiltonian matrix H over a time step dt.\n\nArguments\n\nH: The Hamiltonian matrix representing the dynamics of the system.\ndt: The time step for the evolution.\n\nReturns\n\nThe superoperator matrix representing the Hamiltonian evolution over the specified time step.\n\nExamples\n\njulia> H = [1 1im; -1im -1]\n2×2 Matrix{Complex{Int64}}:\n 1+0im   0+1im\n 0-1im  -1+0im\n\njulia> HamiltonianEvolutionSuperOp(H, 0.1)\n4×4 Matrix{ComplexF64}:\n   0.990066+0.0im           0.098672+0.00993351im    0.098672-0.00993351im    0.00993351+0.0im\n  -0.098672-0.00993351im    0.970199+0.197344im     -0.00993351+0.0im         0.098672+0.00993351im\n  -0.098672+0.00993351im   -0.00993351+0.0im         0.970199-0.197344im      0.098672-0.00993351im\n   0.00993351+0.0im        -0.098672-0.00993351im   -0.098672+0.00993351im    0.990066+0.0im\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.LeftSuperOp","page":"Home","title":"QuantumUtilities.LeftSuperOp","text":"LeftSuperOp(A, d=size(A)[2])\n\nComputes the Liouville space left superoperator representation of a matrix A.\n\nArguments\n\nA: The input matrix.\nd: (Optional) The size of the identity matrix. If not provided, it is set to the number of columns in A.\n\nReturns\n\nThe left superoperator matrix obtained by performing a Kronecker product between the identity matrix and A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> LeftSuperOp(A)\n4×4 Matrix{Int64}:\n 1  2  0  0\n 3  4  0  0\n 0  0  1  2\n 0  0  3  4\n\n\n\n\n\n","category":"function"},{"location":"#QuantumUtilities.RightSuperOp","page":"Home","title":"QuantumUtilities.RightSuperOp","text":"RightSuperOp(A, d=size(A)[1])\n\nComputes the Liouville space right superoperator representation of a matrix A.\n\nArguments\n\nA: The input matrix.\nd: (Optional) The size of the identity matrix. If not provided, it is set to the number of rows in A.\n\nReturns\n\nThe right superoperator matrix obtained by performing a Kronecker product between the transpose of A and the identity matrix.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> RightSuperOp(A)\n4×4 Matrix{Int64}:\n 1  0  3  0\n 0  1  0  3\n 2  0  4  0\n 0  2  0  4\n\n\n\n\n\n","category":"function"},{"location":"#QuantumUtilities.operator2vector-Tuple{Any}","page":"Home","title":"QuantumUtilities.operator2vector","text":"operator2vector(A)\n\nConverts a matrix or array-like object A into a one-dimensional vector.\n\nArguments\n\nA: The input matrix or array-like object.\n\nReturns\n\nA one-dimensional vector representing the elements of A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> operator2vector(A)\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.partial_trace-Tuple{AbstractMatrix, Any, Any}","page":"Home","title":"QuantumUtilities.partial_trace","text":"partial_trace(ρ::AbstractMatrix, keep, dims)\n\nComputes the partial trace of a density matrix ρ by tracing out the specified subsystems.\n\nArguments\n\nρ::AbstractMatrix: The input density matrix.\nkeep: The indices of the subsystems to keep in the partial trace.\ndims: The dimensions of the subsystems.\n\nReturns\n\nThe partial trace of the input density matrix.\n\nExamples\n\njulia> A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]\n4×4 Matrix{Int64}:\n  1   2   3   4\n  5   6   7   8\n  9  10  11  12\n 13  14  15  16\n\njulia> partial_trace(A, [2], [2, 2])\n2×2 Matrix{Int64}:\n 12  14\n 20  22\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.partial_trace-Tuple{AbstractVector, Any, Any}","page":"Home","title":"QuantumUtilities.partial_trace","text":"partial_trace(v::AbstractVector, keep, dims)\n\nComputes the partial trace of a pure state v.\n\nArguments\n\nv::AbstractVector: The input pure state.\nkeep: The indices of the subsystems to keep in the partial trace.\ndims: The dimensions of the subsystems.\n\nReturns\n\nThe partial trace of the input state.\n\nExamples\n\njulia> v = [1, 0]\n2-element Vector{Int64}:\n 1\n 0\n\njulia> w = [1, 1]/sqrt(2)\n2-element Vector{Float64}:\n 0.7071067811865475\n 0.7071067811865475\n\njulia> vw = tensor(v,w)\n4-element Vector{Float64}:\n 0.7071067811865475\n 0.7071067811865475\n 0.0\n 0.0\n\njulia> partial_trace(vw, [2], [2, 2])\n2×2 Matrix{Float64}:\n 0.5  0.5\n 0.5  0.5\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.tensor","page":"Home","title":"QuantumUtilities.tensor","text":"tensor(A, B...)\n\nComputes the tensor product of matrices or array-like objects A and B.\n\nArguments\n\nA: The first matrix or array-like object.\nB...: Additional matrices or array-like objects to compute their tensor product with A.\n\nReturns\n\nThe tensor product of the input matrices or array-like objects.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> B = [5 6; 7 8]\n2×2 Matrix{Int64}:\n 5  6\n 7  8\n\njulia> C = [9 10; 11 12]\n2×2 Matrix{Int64}:\n 9   10\n 11  12\n\njulia> tensor(A, B)\n4×4 Matrix{Int64}:\n  5   6  10  12\n  7   8  14  16\n 15  18  20  24\n 21  24  28  32\n\njulia> tensor(A, B, C)\n8×8 Matrix{Int64}:\n  45   50   54   60   90  100  108  120\n  55   60   66   72  110  120  132  144\n  63   70   72   80  126  140  144  160\n  77   84   88   96  154  168  176  192\n 135  150  162  180  180  200  216  240\n 165  180  198  216  220  240  264  288\n 189  210  216  240  252  280  288  320\n 231  252  264  288  308  336  352  384\n\n\n\n\n\n","category":"function"},{"location":"#QuantumUtilities.vector2operator","page":"Home","title":"QuantumUtilities.vector2operator","text":"vector2operator(v, d=round(Int, sqrt(prod(size(v)))))\n\nReshapes a one-dimensional vector v into a matrix of size d by d.\n\nArguments\n\nv: The input one-dimensional vector.\nd: (Optional) The desired size of the resulting matrix. If not provided, it is calculated as the rounded integer square root of the number of elements in v.\n\nReturns\n\nA matrix of size d by d representing the elements of v reshaped accordingly.\n\nExamples\n\n```julia julia> v = [1, 3, 2, 4] 4-element Vector{Int64}:  1  3  2  4\n\njulia> vector2operator(v) 2×2 Matrix{Int64}:  1  2  3  4 ``\n\n\n\n\n\n","category":"function"}]
}
