var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumUtilities","category":"page"},{"location":"#QuantumUtilities","page":"Home","title":"QuantumUtilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumUtilities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumUtilities]","category":"page"},{"location":"#QuantumUtilities.AntiCommutatorSuperOp-Tuple{Any}","page":"Home","title":"QuantumUtilities.AntiCommutatorSuperOp","text":"AntiCommutatorSuperOp(A)\n\nComputes the Liouville space superoperator representation of the anti-commutator with a matrix A.\n\nArguments\n\nA: The input matrix.\n\nReturns\n\nThe anti-commutator superoperator matrix obtained by adding the right superoperator of A to the left superoperator of A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> AntiCommutatorSuperOp(A)\n4×4 Matrix{Int64}:\n 2  2  3  0\n 3  5  0  3\n 2  0  5  2\n 0  2  3  8\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.CommutatorSuperOp-Tuple{Any}","page":"Home","title":"QuantumUtilities.CommutatorSuperOp","text":"CommutatorSuperOp(A)\n\nComputes the Liouville space superoperator representation of the commutator with a matrix A.\n\nArguments\n\nA: The input matrix.\n\nReturns\n\nThe commutator superoperator matrix obtained by subtracting the right superoperator of A from the left superoperator of A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> CommutatorSuperOp(A)\n4×4 Matrix{Int64}:\n  0   2  -3   0\n  3   3   0  -3\n -2   0  -3   2\n  0  -2   3   0\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.HamiltonianEvolutionSuperOp-Tuple{Any, Any}","page":"Home","title":"QuantumUtilities.HamiltonianEvolutionSuperOp","text":"HamiltonianEvolutionSuperOp(H, dt)\n\nComputes the superoperator corresponding to the Hamiltonian evolution of a system governed by the Hamiltonian matrix H over a time step dt.\n\nArguments\n\nH: The Hamiltonian matrix representing the dynamics of the system.\ndt: The time step for the evolution.\n\nReturns\n\nThe superoperator matrix representing the Hamiltonian evolution over the specified time step.\n\nExamples\n\njulia> H = [1 1im; -1im -1]\n2×2 Matrix{Complex{Int64}}:\n 1+0im   0+1im\n 0-1im  -1+0im\n\njulia> HamiltonianEvolutionSuperOp(H, 0.1)\n4×4 Matrix{ComplexF64}:\n   0.990066+0.0im           0.098672+0.00993351im    0.098672-0.00993351im    0.00993351+0.0im\n  -0.098672-0.00993351im    0.970199+0.197344im     -0.00993351+0.0im         0.098672+0.00993351im\n  -0.098672+0.00993351im   -0.00993351+0.0im         0.970199-0.197344im      0.098672-0.00993351im\n   0.00993351+0.0im        -0.098672-0.00993351im   -0.098672+0.00993351im    0.990066+0.0im\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.LeftSuperOp","page":"Home","title":"QuantumUtilities.LeftSuperOp","text":"LeftSuperOp(A, d=size(A)[2])\n\nComputes the Liouville space left superoperator representation of a matrix A.\n\nArguments\n\nA: The input matrix.\nd: (Optional) The size of the identity matrix. If not provided, it is set to the number of columns in A.\n\nReturns\n\nThe left superoperator matrix obtained by performing a Kronecker product between the identity matrix and A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> LeftSuperOp(A)\n4×4 Matrix{Int64}:\n 1  2  0  0\n 3  4  0  0\n 0  0  1  2\n 0  0  3  4\n\n\n\n\n\n","category":"function"},{"location":"#QuantumUtilities.RightSuperOp","page":"Home","title":"QuantumUtilities.RightSuperOp","text":"RightSuperOp(A, d=size(A)[1])\n\nComputes the Liouville space right superoperator representation of a matrix A.\n\nArguments\n\nA: The input matrix.\nd: (Optional) The size of the identity matrix. If not provided, it is set to the number of rows in A.\n\nReturns\n\nThe right superoperator matrix obtained by performing a Kronecker product between the transpose of A and the identity matrix.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> RightSuperOp(A)\n4×4 Matrix{Int64}:\n 1  0  3  0\n 0  1  0  3\n 2  0  4  0\n 0  2  0  4\n\n\n\n\n\n","category":"function"},{"location":"#QuantumUtilities.cauchy_quadgk-Tuple{Any, Any, Any}","page":"Home","title":"QuantumUtilities.cauchy_quadgk","text":"cauchy_quadgk(g, a, b; kws...)\n\nComputes the Cauchy principal value of the integral of a function g over the interval [a, b] using the quadgk quadrature method.\n\nArguments\n\ng: The function to integrate.\na: The lower bound of the interval.\nb: The upper bound of the interval.\nkws...: Additional keyword arguments accepted by quadgk.\n\nReturns\n\nA tuple (I, E) containing the approximated integral I and an estimated upper bound on the absolute error E.\n\nThrows\n\nArgumentError: If the interval [a, b] does not include zero.\n\nExamples\n\njulia> g(x) = 1 / (x^2 + 1)\n\njulia> cauchy_quadgk(g, -1, 1)\n(-1.1080229582878788e-15, 1.312923433975867e-16)\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.operator2vector-Tuple{Any}","page":"Home","title":"QuantumUtilities.operator2vector","text":"operator2vector(A)\n\nConverts a matrix or array-like object A into a one-dimensional vector.\n\nArguments\n\nA: The input matrix or array-like object.\n\nReturns\n\nA one-dimensional vector representing the elements of A.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> operator2vector(A)\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.partial_trace-Tuple{AbstractMatrix, Any, Any}","page":"Home","title":"QuantumUtilities.partial_trace","text":"partial_trace(ρ::AbstractMatrix, keep, dims)\n\nComputes the partial trace of a density matrix ρ by tracing out the specified subsystems.\n\nArguments\n\nρ::AbstractMatrix: The input density matrix.\nkeep: The indices of the subsystems to keep in the partial trace.\ndims: The dimensions of the subsystems.\n\nReturns\n\nThe partial trace of the input density matrix.\n\nExamples\n\njulia> A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]\n4×4 Matrix{Int64}:\n  1   2   3   4\n  5   6   7   8\n  9  10  11  12\n 13  14  15  16\n\njulia> partial_trace(A, [2], [2, 2])\n2×2 Matrix{Int64}:\n 12  14\n 20  22\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.partial_trace-Tuple{AbstractVector, Any, Any}","page":"Home","title":"QuantumUtilities.partial_trace","text":"partial_trace(v::AbstractVector, keep, dims)\n\nComputes the partial trace of a pure state v.\n\nArguments\n\nv::AbstractVector: The input pure state.\nkeep: The indices of the subsystems to keep in the partial trace.\ndims: The dimensions of the subsystems.\n\nReturns\n\nThe partial trace of the input state.\n\nExamples\n\njulia> v = [1, 0]\n2-element Vector{Int64}:\n 1\n 0\n\njulia> w = [1, 1]/sqrt(2)\n2-element Vector{Float64}:\n 0.7071067811865475\n 0.7071067811865475\n\njulia> vw = tensor(v,w)\n4-element Vector{Float64}:\n 0.7071067811865475\n 0.7071067811865475\n 0.0\n 0.0\n\njulia> partial_trace(vw, [2], [2, 2])\n2×2 Matrix{Float64}:\n 0.5  0.5\n 0.5  0.5\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.realifclose-Tuple{Number}","page":"Home","title":"QuantumUtilities.realifclose","text":"realifclose(x::Complex{T}; tol=eps(T)) where T <: AbstractFloat\n\nReturns the real part of the complex number x if the imaginary part is close to zero within a specified tolerance, and returns x otherwise.\n\nArguments\n\nx::Complex{T}: The input complex number.\ntol::AbstractFloat: The tolerance for considering the imaginary part close to zero. Defaults to eps(T).\n\nReturns\n\nThe real part of x if the imaginary part is close to zero within the specified tolerance, otherwise x itself.\n\nExamples\n\njulia> realifclose(2 + 0im)\n2\n\njulia> realifclose(1e-21 + 1e-21im)\n1.0e-21\n\njulia> realifclose(1e-21 + 1e-21im; tol=1e-22)\n1.0e-21 + 1.0e-21im\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.scrap-Tuple{AbstractFloat}","page":"Home","title":"QuantumUtilities.scrap","text":"scrap(x::AbstractFloat; tol=eps(typeof(x)))\n\nReturns a floating-point number with a small value set to zero within a specified tolerance.\n\nArguments\n\nx::AbstractFloat: The input floating-point number.\ntol: The tolerance for considering the input value close to zero. Defaults to eps(typeof(x)).\n\nReturns\n\nA floating-point number with a small value set to zero within the specified tolerance.\n\nExamples\n\njulia> scrap(1.2e-21)\n0.0\n\njulia> scrap(1.2e-21; tol=1e-22)\n1.2e-21\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.scrap-Union{Tuple{Complex{T}}, Tuple{T}} where T<:AbstractFloat","page":"Home","title":"QuantumUtilities.scrap","text":"scrap(x::Complex{T}; tol=eps(T)) where T <: AbstractFloat\n\nReturns a complex number with small real and imaginary parts set to zero within a specified tolerance.\n\nArguments\n\nx::Complex{T}: The input complex number.\ntol::AbstractFloat: The tolerance for considering the real and imaginary parts close to zero. Defaults to eps(T).\n\nReturns\n\nA complex number with small real and imaginary parts set to zero within the specified tolerance.\n\nExamples\n\njulia> scrap(1e-20 + 1e-21im)\n1.0e-20 + 1.0e-21im\n\njulia> scrap(1e-20 + 1e-25im)\n1.0e-20\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.tensor","page":"Home","title":"QuantumUtilities.tensor","text":"tensor(A, B...)\n\nComputes the tensor product of matrices or array-like objects A and B.\n\nArguments\n\nA: The first matrix or array-like object.\nB...: Additional matrices or array-like objects to compute their tensor product with A.\n\nReturns\n\nThe tensor product of the input matrices or array-like objects.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> B = [5 6; 7 8]\n2×2 Matrix{Int64}:\n 5  6\n 7  8\n\njulia> C = [9 10; 11 12]\n2×2 Matrix{Int64}:\n 9   10\n 11  12\n\njulia> tensor(A, B)\n4×4 Matrix{Int64}:\n  5   6  10  12\n  7   8  14  16\n 15  18  20  24\n 21  24  28  32\n\njulia> tensor(A, B, C)\n8×8 Matrix{Int64}:\n  45   50   54   60   90  100  108  120\n  55   60   66   72  110  120  132  144\n  63   70   72   80  126  140  144  160\n  77   84   88   96  154  168  176  192\n 135  150  162  180  180  200  216  240\n 165  180  198  216  220  240  264  288\n 189  210  216  240  252  280  288  320\n 231  252  264  288  308  336  352  384\n\n\n\n\n\n","category":"function"},{"location":"#QuantumUtilities.usinc-Tuple{Any}","page":"Home","title":"QuantumUtilities.usinc","text":"usinc(x)\n\nComputes the unnormalized sinc function value for the input x, defined as sin(x)/x.\n\nArguments\n\nx: The input value.\n\nReturns\n\nThe unnormalized sinc function value of x.\n\nExamples\n\njulia> usinc(0.5)\n0.958851077208406\n\njulia> usinc(0.0)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"#QuantumUtilities.vector2operator","page":"Home","title":"QuantumUtilities.vector2operator","text":"vector2operator(v, d=round(Int, sqrt(prod(size(v)))))\n\nReshapes a one-dimensional vector v into a matrix of size d by d.\n\nArguments\n\nv: The input one-dimensional vector.\nd: (Optional) The desired size of the resulting matrix. If not provided, it is calculated as the rounded integer square root of the number of elements in v.\n\nReturns\n\nA matrix of size d by d representing the elements of v reshaped accordingly.\n\nExamples\n\n```julia julia> v = [1, 3, 2, 4] 4-element Vector{Int64}:  1  3  2  4\n\njulia> vector2operator(v) 2×2 Matrix{Int64}:  1  2  3  4 ``\n\n\n\n\n\n","category":"function"}]
}
